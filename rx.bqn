#!/usr/bin/env bqn

# TODO need to support error bubbling (would simplify tests...)
future â‡ {
	# TODO types
	# TODO: add lazy mode
	Eagerâ‡{ ğ•Š executor:
		pendingListenersâ†valueBoxâ†âŸ¨âŸ©
		# TODO Unwrap more eagerly? Also, maybe clean this up a little...
		Dispatchâ†{cb ğ•Š v: # Unwrap v then pass to cb.
			{
				âŸ¨tâ‡thenâŸ© : v.Then {{cb Dispatch ğ•©}}
			;	CB v
			} v
			@
		}
		Resolverâ†{ğ•Š value:
			DispatchâŸœvalueÂ¨pendingListeners
			pendingListenersâ€¿valueBoxâ†©âŸ¨âŸ©â€¿âŸ¨valueâŸ©
			value
		}
		Executor resolver
		# TODO: Support list of chained callbacks
		# TODO: Have _Then_ modifier instead?
		Thenâ‡{ğ•Š listener :
			Eager {{ğ•Š resolve :
				Doneâ†Resolveâˆ˜Listener
				{
					  ğ•Š âŸ¨resultâŸ© : done Dispatch result
					; ğ•Š âŸ¨âŸ©     : pendingListeners âˆ¾â†© done
				} valueBox â‹„ @
			}}
		}
	}
	Ofâ‡{ğ•©.thenâ‹„ğ•©}âŠ{ğ•Š v: Eager {{ğ• v}}}
	neverâ‡Eager {{ğ•¤}}
	# TODO make implicit by accepting list in Then...
	Chainâ‡(Of @)âŠ¸({ğ•¨.Then ğ•©}ËœÂ´) âŒ½

	# TODO race, all...
}

# Async linked lists
emptyâ†future.Of @

Consâ‡{head ğ•Š tail: #â‹ˆ
	(future.Of head).Then {{ ğ•© â‹ˆ future.Of(tail) }}
}




_ForEachâ‡{F _ForEach ğ•©:
	(Of ğ•©).Then {{
		@             : @
	;	âŸ¨value, restâŸ© :
			F value
			F _ForEach rest
	}}
	@
}

# Ë˜ â†’ Ë½ ?
# TODO should act as Ë˜ for lists
# (And probably more like Â¨ instead??)
_Cellsâ‡{ F _Cells ğ•©:
	(Of ğ•©).Then {{
		@             : @
	;	âŸ¨value, restâŸ© :
		headâ† F value # Order of evaluation matters here!
		tailâ† F _Cells rest
		head Cons tail
	}}
}

# ` â†’ ??? (greek lower numeral sign)? 
# TODO make initial value (ğ•¨) optional
_Scanâ‡{ acc Cb _Scan stream:
	{accâ†© acc Cb ğ•©} _Cells stream
}

# TODO think more about eval order...
_Reduceâ‡{ acc F _Reduce stream:
	stream.Then {{
		@: acc
	;	 âŸ¨value, restâŸ©: (acc F value) F _Reduce rest
	}}
}

# Procedural interface for building streams.
Signalâ‡{ğ•Š ğ•©:
	res â† @ # "resolve" function for next value
	rootâ†future.Eager {{resâ†©ğ•©}}
	Pushâ†{
		râ†@
		Res ğ•© Cons future.Eager{{Râ†©ğ•}}
		Resâ†©R
	}
	Closeâ†{ğ•¤â‹„
		Res @
		resâ†©@
	}
	ğ• {pushâ‡push, closeâ‡close}
	root
}

## Combining operators ## 
Combineâ‡{a ğ•Š b: 
	Signal{{ğ•Š pushâ€¿close:
		Push _ForEach a
		Push _ForEach b
		future.Chain âŸ¨
			âŠ¢_ReduceâŸœa,
			âŠ¢_ReduceâŸœb,
			Close
		âŸ©
	}}
}

# Operator for two-way data binding.
_BindOldâ‡{a XForm _Bind b:  # TODO Clean or rename...
	Signal{{ğ•Š pushâ€¿close:
		{Push âŸ¨ğ•©, XForm ğ•©âŸ©} _ForEach a
		{Push âŸ¨XFormâ¼ğ•©, ğ•©âŸ©} _ForEach b
		future.ChainâŸ¨
			âŠ¢_ReduceâŸœa,
			âŠ¢_ReduceâŸœb,
			Close
		âŸ©
	}}
}
_Bindâ‡{a XForm _Bind b:
	asâ†a Combine XFormâ¼ _Cells b
	bsâ†b Combine XForm _Cells a   
	âŸ¨as, bsâŸ©

}
# TODO https://mlochbaum.github.io/BQN/doc/rebqn.html#primitives
# - you can also redefine existing primitives to have time-polymorphism
# - but for now just need a few operators...

rxType â† 983191 # Random number

# Wrap ğ•© in a stream if it isn't already
# TODO: We should be able to do this without copying the whole dang thing.
# TODO NEXT: This type checking is not strict enough!
Ofâ‡{
	(future.Of ğ•©).Then {{
		@             : @ 
	;	âŸ¨h, âŸ¨tâ‡thenâŸ©âŸ© : ğ•© # TODO: Terser?
	;	ğ•©â€¿empty 
	}}
}

# I considered replacing builtins with "temporally agnostic"
# replacements... but for that to work we probably need language
# support for blocking async functions (Go style concurrency).
#
# This is probably easier for now anyway.
rxPrimitivesâ‡âŸ¨
	âŸ¨'á´—', _CellsâŸ©,
	âŸ¨'â‚', _ScanâŸ©,
	âŸ¨'â‚', _ReduceâŸ©,
	âŸ¨'â‚Š', _BindâŸ©,
	âŸ¨'â¨', CombineâŸ©, # analogy: ??
	âŸ¨'âŒ¹', ConsâŸ©, # analogy: â‹ˆ
âŸ©
# TODO: Concat

rxbqn â‡ â€¢ReBQN {
	primitivesâ‡â€¢primitivesâˆ¾rxPrimitives
	replâ‡"loose"
	scopeâ‡"read"
}

# Adapted from https://mlochbaum.github.io/BQN/doc/rebqn.html#primitives
#{
#  # Run on a file
#  0 < â‰ â€¢args ?
#    f â† â€¢wdpath â€¢file.At âŠ‘â€¢args
#    pathâ€¿name â† (âˆ§`âŒ¾âŒ½'/'âŠ¸â‰ )âŠ¸âŠ”f
#    âŸ¨path,name,1â†“â€¢argsâŸ© RxBqn â€¢file.Chars f
#  # Do nothing -- assume imported.
#  ; @
#}
